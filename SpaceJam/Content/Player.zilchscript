class Player : ZilchComponent
{
  // Dependencies
  [Dependency] var Transform : Transform;
  [Dependency] var RigidBody : RigidBody;
  [Dependency] var NetUser : NetUser;
  [Dependency] var SweptController : SweptController;
  
  // Player info string used for logging.
  var PlayerInfo : String
  {
    get { return "<Player #`this.NetUser.NetUserId`>"; }
  }
  
  // Input Keys
  [Property] var MoveForwardKey : Keys = Keys.W;
  [Property] var MoveLeftKey : Keys = Keys.A;
  [Property] var MoveBackKey : Keys = Keys.S;
  [Property] var MoveRightKey : Keys = Keys.D;
  
  [Property] var JumpKey : Keys = Keys.Space;
  
  // Player input set by the owning client.
  // (Here we specify in the NetProperty attribute that these properties should replicate over the ClientAuthority NetChannel.
  // This NetChannel configuration specifies that the client who "owns" this NetObject has the authority to replicate property changes
  // to the server and have those values be accepted and applied. The server then relays these changes to the other clients.)
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputUp : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputDown : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputLeft : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputRight : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputJump : Boolean;
  
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputShoot : Boolean;
  
  var LastInputShoot : Boolean;
  
  var MyClient_Hud : Space;
  
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputAngle : Real2
  {
    get { return this.InputAngleInternal; }
    set
    {
      value.Y = Math.Clamp(value.Y, -Math.Pi / 2, Math.Pi / 2);
      this.InputAngleInternal = value;
    }
  }
  var InputAngleInternal : Real2;
  
  [Property]
  var Sensativity : Real2 = Real2(0.005, 0.005);
  
  function Initialize(init : CogInitializer)
  {
    // If we're the server, we're responsible for processing the player's inputs set by the owning client.
    if(this.NetUser.IsServer)
    {
      Zero.Connect(this.Owner, Events.NetChannelIncomingPropertyChanged, this.Server_OnNetChannelIncomingPropertyChanged);
      Zero.Connect(this.Space, Events.LogicUpdate, this.Server_OnLogicUpdate);
    }
    
    // We are a client and this player belongs to us?
    // (Remember, this logic is being run by everyone, that includes the server
    // and other clients, so we must check to see if this player is specifically ours.)
    if(this.NetUser.IsClient)
    {
      if (this.NetUser.IsMine)
      {
        this.MyClient_Hud = this.GameSession.CreateSpace(Archetype.NonNetworkedSpace);
        this.MyClient_Hud.LoadLevel(Level.Hud);
        
        Zero.Mouse.Trapped = true;
        Zero.Connect(Zero.Keyboard, Events.KeyDown, this.MyClient_OnKeyDown);
        Zero.Connect(Zero.Keyboard, Events.KeyUp, this.MyClient_OnKeyUp);
        Zero.Connect(this.Space, Events.MouseMove, this.MyClient_OnMouseMove);
        Zero.Connect(this.Owner, Events.CogDestroy, this.MyClient_OnCogDestroy);
      }
      // Other client
      else
      {
        var cameraCog = this.Owner.FindChildByName("Camera");
        cameraCog.CameraViewport.RenderInGame = false;
        cameraCog.SoundListener.Active = false;
      }
      
      Zero.Connect(this.Space, Events.LogicUpdate, this.Client_OnLogicUpdate);
    }
  }

  function MyClient_OnCogDestroy(event : ObjectEvent)
  {
    Zero.Mouse.Trapped = false;
  }
  
  //
  // Both-Sides
  //
  
  function UpdateAngles()
  {
    this.Transform.WorldRotation = Math.AxisAngle(Real3.YAxis, -this.InputAngle.X);
    
    var characterAnimations = this.Owner.FindChildByName("Character").CharacterAnimations;
    characterAnimations.VerticalAngle = -this.InputAngle.Y;
    characterAnimations.HorizontalAngle = this.InputAngle.X;
  }
  
  //
  // Client-Side
  //
  
  function MyClient_OnMouseMove(event : ViewportMouseEvent)
  {
    this.InputAngle += event.Movement * this.Sensativity;
  }
  
  function MyClient_OnKeyDown(event : KeyboardEvent)
  {
    this.MyClient_OnKeyChanged(event, true);
  }
  function MyClient_OnKeyUp(event : KeyboardEvent)
  {
    this.MyClient_OnKeyChanged(event, false);
  }
  function MyClient_OnKeyChanged(event : KeyboardEvent, state : Boolean)
  {
    // Set input state.
    // (Since these input properties are client authoritative, the network system will automatically replicate these
    // changes to the server, which will accept the changes without question.)
    if(event.Key == this.MoveForwardKey)
      this.InputUp = state;
    else if(event.Key == this.MoveBackKey)
      this.InputDown = state;
    else if(event.Key == this.MoveLeftKey)
      this.InputLeft = state;
    else if(event.Key == this.MoveRightKey)
      this.InputRight = state;
    else if(event.Key == this.JumpKey)
      this.InputJump = state;
  }
  
  function Client_OnLogicUpdate(event : UpdateEvent)
  {
    this.UpdateAngles();
    
    if (this.NetUser.IsMine)
      this.InputShoot = Zero.Mouse.IsButtonDown(MouseButtons.Left);
    
    if (this.InputShoot && !this.LastInputShoot)
    {
      var pistol = this.Owner.FindChildByName("Pistol");
      var graph = pistol.AnimationGraph;
      graph.ActiveNode = graph.CreateBasicNode(Animation.PistolShoot, AnimationPlayMode.PlayOnce);
      
      var flarePoint = pistol.FindChildByName("FlarePoint");
      var flare = this.Space.Create(Archetype.MuzzleFlare);
      flare.AttachTo(flarePoint);
      flare.Transform.LocalScale = Real3(1, 1, 1);
      flare.Transform.LocalTranslation = Real3.Zero;
      flare.Transform.LocalRotation = Quaternion.Identity;
      
      pistol.SoundEmitter.PlayCue(SoundCue.Gunshot);
    }
    this.LastInputShoot = this.InputShoot;
  }
  
  //
  // Server-Side
  //
  
  function Server_OnLogicUpdate(event : UpdateEvent)
  {
    // Compute the player movement vector based on the client's input.
    var movement = Real3(0, 0, 0);
    
    // (These input property values are replicated to us from the owning client whenever their state changes.
    // We are still authoritative over the player's other properties, such as Translation and Rotation,
    // so clients are unable to cheat by trying to set their own position / orientation.)
    if(this.InputUp)
      movement -= Real3.ZAxis;
    if(this.InputDown)
      movement += Real3.ZAxis;
    if(this.InputLeft)
      movement -= Real3.XAxis;
    if(this.InputRight)
      movement += Real3.XAxis;
    
    // Normalize the movement vector (so player's can't move faster diagonally)
    // and scale it by our movement scalar so our player's go as fast we want them to.
    movement = Math.Normalize(movement);
    
    // Apply a force to move the player in the direction the client intended.
    movement = this.Transform.TransformNormal(movement);
    this.SweptController.Update(movement, event.Dt);
    
    //Handle Jumping
    if(this.InputJump)
      this.SweptController.Jump();
    
    var characterAnimations = this.Owner.FindChildByName("Character").CharacterAnimations;
    characterAnimations.Jumping = !this.SweptController.Grounded;
    
    this.UpdateAngles();
  }
  
  function Server_OnNetChannelIncomingPropertyChanged(event : NetChannelPropertyChange)
  {
    // Ex. This is the best place to handle "toggled" property logic or property logic with a clear "begin" / "end".
    // This could include things like player crouching ("toggled") or starting an attack and ending an attack (clear "begin" / "end").
    
    // Get the current property value from the property that was just changed.
    var propertyValue : Boolean = false;
    if(event.PropertyName == "InputUp")
      propertyValue = this.InputUp;
    else if(event.PropertyName == "InputDown")
      propertyValue = this.InputDown;
    else if(event.PropertyName == "InputLeft")
      propertyValue = this.InputLeft;
    else if(event.PropertyName == "InputRight")
      propertyValue = this.InputRight;
    else
      return;
    
    // Print whether or not that input was pressed or released.
    if(propertyValue)
      this.GameSession.GameLogger.WriteLine("`this.PlayerInfo` Pressed `event.PropertyName` at `event.Timestamp`s.");
    else
      this.GameSession.GameLogger.WriteLine("`this.PlayerInfo` Released `event.PropertyName` at `event.Timestamp`s.");
  }
}
