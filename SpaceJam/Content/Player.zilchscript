class Player : ZilchComponent
{
  // Dependencies
  [Dependency] var RigidBody : RigidBody;
  [Dependency] var NetUser : NetUser;
  [Dependency] var SweptController : SweptController;
  
  // Player info string used for logging.
  var PlayerInfo : String
  {
    get { return "<Player #`this.NetUser.NetUserId`>"; }
  }
  
  // Input Keys
  [Property] var MoveForwardKey : Keys = Keys.W;
  [Property] var MoveLeftKey : Keys = Keys.A;
  [Property] var MoveBackKey : Keys = Keys.S;
  [Property] var MoveRightKey : Keys = Keys.D;
  
  [Property] var JumpKey : Keys = Keys.Space;
  
  // Player input set by the owning client.
  // (Here we specify in the NetProperty attribute that these properties should replicate over the ClientAuthority NetChannel.
  // This NetChannel configuration specifies that the client who "owns" this NetObject has the authority to replicate property changes
  // to the server and have those values be accepted and applied. The server then relays these changes to the other clients.)
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputUp : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputDown : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputLeft : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputRight : Boolean;
  [NetProperty(netChannelConfig : "ClientAuthority")]
  var InputJump : Boolean;
  
  function Initialize(init : CogInitializer)
  {
    // If we're the server, we're responsible for processing the player's inputs set by the owning client.
    if(this.NetUser.IsServer)
    {
      Zero.Connect(this.Owner, Events.NetChannelIncomingPropertyChanged, this.Server_OnNetChannelIncomingPropertyChanged);
      Zero.Connect(this.Space, Events.LogicUpdate, this.Server_OnLogicUpdate);
    }
    
    // We are a client and this player belongs to us?
    // (Remember, this logic is being run by everyone, that includes the server
    // and other clients, so we must check to see if this player is specifically ours.)
    if(this.NetUser.IsClientAndMine)
    {
      Zero.Connect(Zero.Keyboard, Events.KeyDown, this.Client_OnKeyDown);
      Zero.Connect(Zero.Keyboard, Events.KeyUp, this.Client_OnKeyUp);
    }
    
  }
  
  //
  // Client-Side Input Events
  //
  
  function Client_OnKeyDown(event : KeyboardEvent)
  {
    // Handle key state change.
    this.Client_OnKeyChanged(event, true);
  }
  function Client_OnKeyUp(event : KeyboardEvent)
  {
    // Handle key state change.
    this.Client_OnKeyChanged(event, false);
  }
  function Client_OnKeyChanged(event : KeyboardEvent, state : Boolean)
  {
    // Set input state.
    // (Since these input properties are client authoritative, the network system will automatically replicate these
    // changes to the server, which will accept the changes without question.)
    if(event.Key == this.MoveForwardKey)
      this.InputUp = state;
    else if(event.Key == this.MoveBackKey)
      this.InputDown = state;
    else if(event.Key == this.MoveLeftKey)
      this.InputLeft = state;
    else if(event.Key == this.MoveRightKey)
      this.InputRight = state;
    else if(event.Key == this.JumpKey)
      this.InputJump = state;
  }
  
  //
  // Server-Side Update Events
  //
  
  function Server_OnLogicUpdate(event : UpdateEvent)
  {
    // Compute the player movement vector based on the client's input.
    var movement = Real3(0, 0, 0);
    
    // (These input property values are replicated to us from the owning client whenever their state changes.
    // We are still authoritative over the player's other properties, such as Translation and Rotation,
    // so clients are unable to cheat by trying to set their own position / orientation.)
    if(this.InputUp)
      movement -= Real3.ZAxis;
    if(this.InputDown)
      movement += Real3.ZAxis;
    if(this.InputLeft)
      movement -= Real3.XAxis;
    if(this.InputRight)
      movement += Real3.XAxis;
    
    // Normalize the movement vector (so player's can't move faster diagonally)
    // and scale it by our movement scalar so our player's go as fast we want them to.
    movement = Math.Normalize(movement);
    
    // Apply a force to move the player in the direction the client intended.
    this.SweptController.Update(movement, event.Dt);
    
    //Handle Jumping
    if(this.InputJump)
      this.SweptController.Jump();
    
    this.Owner.FindChildByName("Character").CharacterAnimations.Jumping = !this.SweptController.Grounded;
  }
  function Server_OnNetChannelIncomingPropertyChanged(event : NetChannelPropertyChange)
  {
    // Ex. This is the best place to handle "toggled" property logic or property logic with a clear "begin" / "end".
    // This could include things like player crouching ("toggled") or starting an attack and ending an attack (clear "begin" / "end").
    
    // Get the current property value from the property that was just changed.
    var propertyValue : Boolean = false;
    if(event.PropertyName == "InputUp")
      propertyValue = this.InputUp;
    else if(event.PropertyName == "InputDown")
      propertyValue = this.InputDown;
    else if(event.PropertyName == "InputLeft")
      propertyValue = this.InputLeft;
    else if(event.PropertyName == "InputRight")
      propertyValue = this.InputRight;
    else
      return;
    
    // Print whether or not that input was pressed or released.
    if(propertyValue)
      this.GameSession.GameLogger.WriteLine("`this.PlayerInfo` Pressed `event.PropertyName` at `event.Timestamp`s.");
    else
      this.GameSession.GameLogger.WriteLine("`this.PlayerInfo` Released `event.PropertyName` at `event.Timestamp`s.");
  }
}
